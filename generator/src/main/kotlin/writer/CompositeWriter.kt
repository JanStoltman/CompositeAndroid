package writer

import autoGeneratedJavadocHeader
import parse.AnalyzedJavaFile
import parse.AnalyzedJavaMethod
import java.io.File


fun writeComposite(outPath: String,
                   javaFile: AnalyzedJavaFile,
                   javaPackage: String,
                   javaClassName: String,
                   extends: String,
                   additionalImports: String = "",
                   transform: ((String) -> String)? = null,
                   superClassPluginNames: List<String> = listOf(),
                   superClassDelegateName: String = "",
                   delegateClassName: String,
                   pluginClassName: String,
                   superClassInputFile: AnalyzedJavaFile? = null,
                   addCodeToClass: String? = null) {

    val allPluginTypes = mutableListOf(pluginClassName)
    allPluginTypes.addAll(superClassPluginNames)


    fun addPlugins(): String {
        return allPluginTypes
                .distinct()
                .map {
                    """
                    |
                    |public Removable addPlugin(final $it plugin) {
                    |    return delegate.addPlugin(plugin);
                    |}
                    |
                    |public List<Removable> add${it}s(@NonNull final $it... plugins) {
                    |    final List<Removable> removables = new ArrayList<>(plugins.length);
                    |    for (final $it plugin : plugins) {
                    |        removables.add(delegate.addPlugin(plugin));
                    |    }
                    |    return removables;
                    |}
                    |
                    |public List<Removable> add${it}s(@NonNull final Iterable<? extends $it> plugins) {
                    |    final List<Removable> removables = new ArrayList<>();
                    |    for (final $it plugin : plugins) {
                    |        removables.add(delegate.addPlugin(plugin));
                    |    }
                    |    return removables;
                    |}
                    """.replaceIndentByMargin("    ")
                }
                .joinToString("\n")
    }

    val sb = StringBuilder("""
    |package com.pascalwelsch.compositeandroid.$javaPackage;
    |
    |import android.annotation.SuppressLint;
    |
    |import com.pascalwelsch.compositeandroid.core.*;
    |
    |${javaFile.imports}
    |
    |$additionalImports
    |import java.util.*;
    |
    |@SuppressWarnings({"unused", "deprecation", "JavadocReference", "WrongConstant", "RestrictedApi"})
    |@SuppressLint({"MissingSuperCall", "NewApi"})
    |
    |$autoGeneratedJavadocHeader
    |public class $javaClassName extends $extends {
    |
    |    protected $delegateClassName delegate = new $delegateClassName(this);
    |
    |${addPlugins()}
    |
    """.replaceIndentByMargin())

    val allMethods = mutableListOf<AnalyzedJavaMethod>()
    if (superClassInputFile != null) {
        allMethods.addAll(superClassInputFile.methods)
    }
    allMethods.addAll(javaFile.methods)
    val distinctMethods = allMethods.distinctBy { "${it.name} ${it.parameterTypes}" }.toMutableList()

    for (method in distinctMethods) with(method) {
        // override method, calling delegate
        sb.appendln(callDelegate())

        // super method
        sb.appendln(callSuper())
    }

    addCodeToClass?.let { sb.appendln(it) }

    sb.appendln("}")

    var output = sb.toString()
    if (transform != null) {
        output = transform(output)
    }

    val out = File("$outPath${javaPackage.replace('.', '/')}/$javaClassName.java")
    out.parentFile.mkdirs()
    out.printWriter().use { it.write(output) }
    System.out.println("wrote ${out.absolutePath}")
}

private fun AnalyzedJavaMethod.callSuper(): String {

    val returnWhenNotVoid = if (returnType != "void") "return " else ""
    val formattedAnnotations = annotations
            .filter { !it.contains("Override") }
            .joinToString("\n")

    return """
            |${javadoc?.trim() ?: ""}
            |$formattedAnnotations
            |@Override
            |public $genericReturnType$returnType super_$name($rawParameters) $exceptions{
            |    ${returnWhenNotVoid}super.$name(${parameterNames.joinToString()});
            |}
            """.replaceIndentByMargin("    ")
}

private fun AnalyzedJavaMethod.callDelegate(): String {

    val returnWhenNotVoid = if (returnType != "void") "return " else ""
    return """
            |
            |${javadoc?.trim() ?: ""}
            |${annotations.joinToString("\n")}
            |public $genericReturnType$returnType $name($rawParameters) $exceptions{
            |${"""
            |    ${returnWhenNotVoid}delegate.$name(${parameterNames.joinToString()});
            """.replaceIndentByMargin().let { it: String ->
        if (throws) """
            |    try {
            |        $it
            |    } catch(SuppressedException e){
            |        throw ($exceptionType) e.getCause();
            |    }
            """.replaceIndentByMargin() else it
    }}
            |}
            """.replaceIndentByMargin("    ")
}

